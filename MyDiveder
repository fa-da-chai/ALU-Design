`timescale 1ns/1ns 

module Diveder( clk, divided, divisor, signal, dataout, reset ) ; // divided è¢«é¤æ¸ divisor é¤æ¸
  // å®ç¾©æ¥ç·
  input clk, reset ;
  input [5:0] signal ;
  input [7:0] divided, divisor ;
  output[15:0] dataout ;
  
  reg start ;
  reg [7:0] quot ;
  reg [15:0] divr, rem ; // æ´åé¤æ¸è¢«é¤æ¸
  reg [15:0] temp ;
  
  parameter DIVU = 6'b011011;
  parameter OUT = 6'b111111;
  
  always@( posedge clk or reset ) begin 
    if ( reset ) begin
      // initialize
      start = 1'b0 ;
      quot = 8'b0 ;
      divr = 16'b0 ;
      rem = 16'b0 ;
      temp = 16'b0 ;
    end
	
    else begin
      if ( start == 0 ) begin
	divr <= { divisor, 8'b0 } ;
	rem <= { 8'b0, divided } ;
	start <= start + 1'b1 ;
      end
	  
      case ( signal )
      DIVU : begin
        rem <= rem - divr ;
	if ( rem[15] == 0 ) begin // positive
	  quot <= quot + 1 ;		  
	end

        else begin // negetive
          rem <= rem + divr ; 
        end

        quot <= { quot[6:0], 1'b0 } ; // shift left
        divr <= { 1'b0, divr[15:1] } ; // shift right
      end
	  
      OUT : begin
	temp[15:8] <= quot ;
        temp[7:0] <= rem ;
      end
      endcase
    end
  end // always block
  
  assign dataout = temp ;
endmodule


`timescale 1ns/1ns 

module TM ;

  reg clk, rst ;
  reg [5:0] signal ;
  reg [7:0] a, b ;
  wire [15:0] out ;

  Diveder U_Divider( .clk(clk), .divided(a), .divisor(b), .signal(signal), .dataout(out), .reset(rst) ) ;

  initial begin
    clk = 1'b1;
    forever #5 clk = ~clk;
  end
  
  initial begin 
    signal = 6'b011011 ;
    a = 8'd65 ;
    b = 8'd5 ;
    rst = 1'b1 ;
    #10 ;
    rst = 1'b0 ;
    #330 ;
    signal = 6'b111111 ; // output signal ;
    #20 ;
    $stop ;
  end
endmodule
